@page "/typeedit/{TypeCode}"
@inject TypeService TypeService
@inject StatusService StatusService
@inject NavigationManager Nav

<h3>Edit Communication Type</h3>

@if (_loading)
{
    <p><em>Loading...</em></p>
}
else if (_typeDetails == null)
{
    <div class="alert alert-danger">Type not found.</div>
}
else
{
    <EditForm Model="_editModel" OnValidSubmit="HandleUpdate">
        <DataAnnotationsValidator />
        <ValidationSummary />

        <div class="mb-3">
            <label class="form-label">Type Code</label>
            <InputText @bind-Value="_editModel.TypeCode" class="form-control" Disabled="true" />
        </div>

        <div class="mb-3">
            <label class="form-label">Display Name</label>
            <InputText @bind-Value="_editModel.DisplayName" class="form-control" />
        </div>

        <div class="form-check mb-3">
            <InputCheckbox @bind-Value="_editModel.IsActive" class="form-check-input" />
            <label class="form-check-label">Active</label>
        </div>

        <h5>Valid Statuses</h5>
        <p class="text-muted">Check which statuses are valid for this type. Descriptions shown below.</p>

        @if (_statusOptions?.Any() != true)
        {
            <div class="alert alert-info">No statuses available for this type.</div>
        }
        else
        {
            <div class="mb-3">
                @foreach (var s in _statusOptions)
                {
                    <div class="form-check">
                        <InputCheckbox @bind-Value="_checked[s.StatusCode]" class="form-check-input" id="@($"chk_{s.StatusCode}")" />
                        <label class="form-check-label" for="@($"chk_{s.StatusCode}")">
                            <strong>@s.StatusCode</strong>
                            <div class="text-muted">@s.Description</div>
                        </label>
                    </div>
                }
            </div>
        }

        <div class="d-flex justify-content-between mt-4">
            <button type="button" class="btn btn-secondary" @onclick="GoBack">‚Üê Back</button>

            <div>
                <button type="button" class="btn btn-danger me-2" @onclick="HandleDelete">Delete</button>
                <button type="submit" class="btn btn-primary" disabled="@(!CanUpdate)">Update</button>
            </div>
        </div>
    </EditForm>
}

@code {
    [Parameter] public string TypeCode { get; set; } = "";

    private TypeDetailsDto? _typeDetails;
    private bool _loading = true;

    // Mutable model used by EditForm
    private class EditModel
    {
        public string TypeCode { get; set; } = "";
        public string DisplayName { get; set; } = "";
        public bool IsActive { get; set; } = true;
    }

    private EditModel _editModel = new();

    // Status options to show (description + code)
    private List<StatusDto> _statusOptions = new();

    // Map: statusCode -> currently checked (UI)
    private Dictionary<string, bool> _checked = new();

    // Original mapping: statusCode -> StatusDto (so we can find Id when deleting)
    private Dictionary<string, StatusDto> _originalMap = new();

    // Update enabled only when display name present (type code is required and read-only)
    private bool CanUpdate =>
        !string.IsNullOrWhiteSpace(_editModel.DisplayName) &&
        !string.IsNullOrWhiteSpace(_editModel.TypeCode);

    protected override async Task OnInitializedAsync()
    {
        await LoadTypeAsync();
    }

    private async Task LoadTypeAsync()
    {
        _loading = true;

        try
        {
            _typeDetails = await TypeService.GetByCodeAsync(TypeCode);

            // populate edit model
            _editModel = new EditModel
            {
                TypeCode = _typeDetails.TypeCode,
                DisplayName = _typeDetails.DisplayName,
                IsActive = _typeDetails.IsActive
            };

            // load statuses for this type (used as options for checkboxes)
            _statusOptions = (await StatusService.GetByTypeAsync(TypeCode)).ToList();

            // build original map and checkbox dictionary
            _originalMap = _typeDetails.ValidStatuses.ToDictionary(s => s.StatusCode, s => s);
            _checked = _statusOptions.ToDictionary(
                s => s.StatusCode,
                s => _originalMap.ContainsKey(s.StatusCode)
            );
        }
        catch
        {
            _typeDetails = null;
        }

        _loading = false;
    }

    private void ToggleChecked(string statusCode, bool isChecked)
    {
        _checked[statusCode] = isChecked;
    }

    private async Task HandleUpdate()
    {
        if (_typeDetails == null) return;

        // Update the type basic fields first
        var updateDto = new TypeUpdateDto(_editModel.TypeCode, _editModel.DisplayName, _editModel.IsActive);
        await TypeService.UpdateAsync(updateDto);

        // Now sync statuses:
        // - For every status that is checked but not present originally -> Add
        // - For every status that is unchecked but present originally -> Delete (by Id)

        foreach (var kv in _checked)
        {
            var statusCode = kv.Key;
            var checkedNow = kv.Value;
            var existed = _originalMap.ContainsKey(statusCode);

            if (checkedNow && !existed)
            {
                // Add the status mapping. Use the description from statusOptions if present.
                var statusDesc = _statusOptions.FirstOrDefault(s => s.StatusCode == statusCode)?.Description ?? statusCode;
                var createDto = new StatusCreateDto(_editModel.TypeCode, statusCode, statusDesc);
                await StatusService.AddAsync(createDto);
            }
            else if (!checkedNow && existed)
            {
                // Delete existing mapping by Id
                var existing = _originalMap[statusCode];
                var deleteDto = new StatusDeleteDto(existing.Id);
                await StatusService.DeleteAsync(deleteDto);
            }
        }

        // After successful update, navigate back to type list
        Nav.NavigateTo("/typelist");
    }

    private async Task HandleDelete()
    {
        if (_typeDetails == null) return;

        var deleteDto = new TypeDeleteDto(_typeDetails.TypeCode);
        await TypeService.DeleteAsync(deleteDto);

        Nav.NavigateTo("/typelist");
    }

    private void GoBack() => Nav.NavigateTo("/typelist");
}
